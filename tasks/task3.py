def my_sort(nums):
    if len(nums) <= 1:
        return nums
    pivot = nums[-1]
    l_nums = my_sort([n for n in nums[:-1] if n < pivot])
    r_num = my_sort([n for n in nums[:-1] if n > pivot])
    sorted_nums = l_nums + [pivot] + r_num
    return sorted_nums

'''
Вроде как алгоритм быстрой сортировки. Разбивает список чисел на два списка меньших и больших элементов относительно
взятого числа (у нас это последний элемент). После этого рекурсивно повторяем, пока не дойдем до глубины, где у нас
останется 1 или 0 элементов. Должен работать со скоростью O(n*log(n)). Но из минусов - если список отсортирован, то -
наихудший сценарий – O(n²).
'''